/* Definition section */
%{
#define BUF_SIZE 10000
#include "y.tab.h"	/* header file generated by bison */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
extern YYSTYPE yylval; //YYSTYPE
extern void dump_symbol();
extern int need_dump;
extern int scope_num;
extern char* expression_id[100];
extern int expression_id_exist[100];
extern char* expression_id_type[100];

char buf[BUF_SIZE];
void printLine();
void clear_expression();
/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
#define FREEBUF { buf[0] = '\0'; }
%}

/* Define regular expression label */
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
float       {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { 
    CONCAT
    return ADD; }
"-" 	{ 
    CONCAT
    return SUB; }
"*" 	{ 
    CONCAT
    return MUL; }
"/" 	{ 
    CONCAT
    return DIV; }
"%"     { 
    CONCAT
    return MOD; }
"++"    { 
    CONCAT
    return INC; }
"--"    { 
    CONCAT
    return DEC; }

 /* Relational */
">"		{ 
    CONCAT
    return MT; }
"<"		{ 
    CONCAT
    return LT; }
">="	{ 
    CONCAT
    return MTE; }
"<="	{ 
    CONCAT
    return LTE; }
"=="	{ 
    CONCAT
    return EQ; }
"!="	{ 
    CONCAT
    return NE; }

 /* Assignment */
"="		{ 
    CONCAT
    return ASGN; }
"+="	{ 
    CONCAT
    return ADDASGN; }
"-="	{ 
    CONCAT
    return SUBASGN; }
"*="	{ 
    CONCAT
    return MULASGN; }
"/="	{ 
    CONCAT
    return DIVASGN; }
"%="	{ 
    CONCAT
    return MODASGN; }

 /* Logical */
"&&"	{ 
    CONCAT
    return AND; }
"||"	{ 
    CONCAT
    return OR; }
"!"		{ 
    CONCAT
    return NOT; }

 /* Delimiters */
"("		{ 
    CONCAT
    return LB; }
")"		{ 
    CONCAT
    return RB; }
"{"		{ 
    CONCAT
    return LCB; }
"}"		{ 
    CONCAT
    return RCB; }
"["		{ 
    CONCAT
    return LSB; }
"]"		{ 
    CONCAT
    return RSB; }
","		{ 
    CONCAT
    return COMMA; }

 /* Print Keywords */	
"print"		{ 
    CONCAT
    return PRINT; }

 /* Condition and Loop Keywords */
"if"		{ 
    CONCAT
    return IF; }
"else"		{ 
    CONCAT
    return ELSE; }
"for"		{ 
    CONCAT
    return FOR; }
"while"		{ 
    CONCAT
    return WHILE; }

 /* Declaration Keywords */
"void"		{ 
    CONCAT
    return VOID; }
"int"		{ 
    CONCAT
    return INT; }
"float"  	{ 
    CONCAT
    return FLOAT; }
"string"  	{ 
    CONCAT
    return STRING; }
"bool"  	{ 
    CONCAT
    return BOOL; }

 /* boolean Keywords */
"true"      { 
    CONCAT
    return TRUE; }
"false"     { 
    CONCAT
    return FALSE; }

"return"    { 
    CONCAT
    return RET; }

 /* String Constant */
\"  {
    CONCAT 
    BEGIN STRING_STATE; }
<STRING_STATE>\"		{ 
    CONCAT
    BEGIN INITIAL; }
<STRING_STATE>[^"]*		{ 
    CONCAT
    return STR_CONST; }

 /* Number Constant */
{integer}	{ 
    CONCAT
    return I_CONST; }
{float}	    { 
    CONCAT
    return F_CONST; }

 /* C type Comment */
"/*"				{ 
    CONCAT
    BEGIN COMMENT; }
<COMMENT>[^*\n]+	{ CONCAT }
<COMMENT>\n			{ 
    CONCAT
    printLine(); }
<COMMENT>"*"		{ CONCAT }
<COMMENT>"*/"		{ 
    CONCAT 
    BEGIN INITIAL; }

 /* C++ type Comment */
\/\/.*	{ CONCAT }

 /* Variable ID */
 {id}       { 
     CONCAT 
     yylval.str_val = (char *)malloc(strlen(yytext) + 1);
     strcpy(yylval.str_val, yytext);
     return ID; }

 /* others */

[;]         { 
    CONCAT 
    return SEMICOLON; }
[\n]        { 
    CONCAT
    clear_expression();
    printLine(); }
[ \t]		{ CONCAT } /* Ignore */
[^ \t\n] 	{ CONCAT } /* Ignore other charactor sets */
<<EOF>>     { return 0; }

%%

int yywrap()
{
    return 1;
}

void printLine() {
    if(!strcmp(buf, "\n"))
        printf("%d:%s", yylineno, buf);
    else
        printf("%d: %s", yylineno, buf);
    if(need_dump) {
        dump_symbol();
        need_dump = 0;
        --scope_num;
    }
    FREEBUF

}

void clear_expression() {
    for(int i = 0; i < 100; ++i) {
        if(expression_id[i])
            free(expression_id[i]);
        expression_id_exist[i] = 1;
        if(expression_id_type[i])
            free(expression_id_type[i]);
    }
}


