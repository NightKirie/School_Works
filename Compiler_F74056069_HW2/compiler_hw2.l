/* Definition section */
%{
#define BUF_SIZE 10000
#include "y.tab.h"	/* header file generated by bison */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
extern YYSTYPE yylval; //YYSTYPE
char buf[BUF_SIZE];

/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
%}

/* Define regular expression label */
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
float       {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { 
    printf("%s", yytext); 
    return ADD; }
"-" 	{ 
    printf("%s", yytext); 
    return SUB; }
"*" 	{ 
    printf("%s", yytext); 
    return MUL; }
"/" 	{ 
    printf("%s", yytext); 
    return DIV; }
"%"     { 
    printf("%s", yytext); 
    return MOD; }
"++"    { 
    printf("%s", yytext); 
    return INC; }
"--"    { 
    printf("%s", yytext); 
    return DEC; }

 /* Relational */
">"		{ 
    printf("%s", yytext); 
    return MT; }
"<"		{ 
    printf("%s", yytext); 
    return LT; }
">="	{ 
    printf("%s", yytext); 
    return MTE; }
"<="	{ 
    printf("%s", yytext); 
    return LTE; }
"=="	{ 
    printf("%s", yytext); 
    return EQ; }
"!="	{ 
    printf("%s", yytext); 
    return NE; }

 /* Assignment */
"="		{ 
    printf("%s", yytext); 
    return ASGN; }
"+="	{ 
    printf("%s", yytext); 
    return ADDASGN; }
"-="	{ 
    printf("%s", yytext); 
    return SUBASGN; }
"*="	{ 
    printf("%s", yytext); 
    return MULASGN; }
"/="	{ 
    printf("%s", yytext); 
    return DIVASGN; }
"%="	{ 
    printf("%s", yytext); 
    return MODASGN; }

 /* Logical */
"&&"	{ 
    printf("%s", yytext); 
    return AND; }
"||"	{ 
    printf("%s", yytext); 
    return OR; }
"!"		{ 
    printf("%s", yytext); 
    return NOT; }

 /* Delimiters */
"("		{ 
    printf("%s", yytext); 
    return LB; }
")"		{ 
    printf("%s", yytext); 
    return RB; }
"{"		{ 
    printf("%s", yytext); 
    return LCB; }
"}"		{ 
    printf("%s", yytext); 
    return RCB; }
"["		{ 
    printf("%s", yytext); 
    return LSB; }
"]"		{ 
    printf("%s", yytext); 
    return RSB; }
","		{ 
    printf("%s", yytext); 
    return COMMA; }

 /* Print Keywords */	
"print"		{ 
    printf("%s", yytext); 
    return PRINT; }

 /* Condition and Loop Keywords */
"if"		{ 
    printf("%s", yytext); 
    return IF; }
"else"		{ 
    printf("%s", yytext); 
    return ELSE; }
"for"		{ 
    printf("%s", yytext); 
    return FOR; }
"while"		{ 
    printf("%s", yytext); 
    return WHILE; }

 /* Declaration Keywords */
"void"		{ 
    printf("%s", yytext); 
    return VOID; }
"int"		{ 
    printf("%s", yytext); 
    return INT; }
"float"  	{ 
    printf("%s", yytext); 
    return FLOAT; }
"string"  	{ 
    printf("%s", yytext); 
    return STRING; }
"bool"  	{ 
    printf("%s", yytext); 
    return BOOL; }

 /* boolean Keywords */
"true"      { 
    printf("%s", yytext); 
    return TRUE; }
"false"     { 
    printf("%s", yytext); 
    return FALSE; }

"return"    { 
    printf("%s", yytext); 
    return RET; }

 /* String Constant */
\"  { BEGIN STRING_STATE; }
<STRING_STATE>\"		{ 
    printf("%s", yytext); 
    BEGIN INITIAL; }
<STRING_STATE>[^"]*		{ 
    printf("%s", yytext); 
    yylval.str_val = malloc(strlen(yytext));
    strcpy(yylval.str_val, yytext);
    return STR_CONST; }

 /* Number Constant */
{integer}	{ 
    printf("%s", yytext); 
    yylval.i_val = atoi(yytext);
    return I_CONST; }
{float}	    { 
    printf("%s", yytext); 
    yylval.f_val = atof(yytext);
    return F_CONST; }

 /* C type Comment */
"/*"				{ 
    printf("%s", yytext); 
    BEGIN STR_COMMENT; }
<COMMENT>[^*\n]+	{ printf("%s", yytext); }
<COMMENT>\n			{ 
    printf("%s", yytext); 
    ++yylineno; }
<COMMENT>"*"		{ printf("%s", yytext); }
<COMMENT>"*/"		{ 
    printf("%s", yytext); 
    BEGIN INITIAL; 
    return STR_COMMENT; }

 /* C++ type Comment */
\/\/.*	{ 
    printf("%s", yytext); 
    return STR_COMMENT; }

 /* Variable ID */
 {id}       { 
     printf("%s", yytext); 
     yylval.str_val = malloc(strlen(yytext));
     strcpy(yylval.str_val, yytext);
     return ID; }

 /* others */

[;]         { 
    printf("%s", yytext); 
    return SEMICOLON; }
[\n]        { printf("%s", yytext); }
[ \t]		{ printf("%s", yytext);  } /* Ignore */
[^ \t\n] 	{ printf("%s", yytext);  } /* Ignore other charactor sets */
<<EOF>>     { return 0; }

%%

int yywrap()
{
    return 1;
}
